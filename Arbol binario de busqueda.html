<!DOCTYPE html>
<html lang="es">
<head>
    <head>
        <meta charset="utf-8"/>
        <title>LVaED</title>
        <meta name="description" content="Este es un aporte hacia el aprendizaje de las estructuras de datos"/>
        <meta name="author" content="Cristian Julian Muñoz Buenahora, John Jairo Corzo Calderon, Santiago Andres DelValle Pinilla"/>
        <meta name="keywords" content="Estructuras de datos"/>
        <link rel="stylesheet" href="Estilos, scripts e imagenes/EstilosPrincipal.css"/>
        <link rel="stylesheet" href="/Estilos, scripts e imagenes/prism.css"/>
        <script src="Estilos, scripts e imagenes/botonArriba.js"></script>
    </head>
    <body>
        <div id="principio">
            <header>
                <h1>Laboratorio virtual para el aprendizaje de estructuras de datos - LVaED</h1> 
            </header>

            <nav> 
                <ul>
                    <li><a href="index.html">Inicio</a></li>
                    <li><a href="EstructurasDeDatos.html">Estructura de datos</a></li>
                    <li><a href="Trasformaciones.html">Trasformaciones</a></li>
                </ul>
            </nav>

            <h1 id="titulo">Árbol binario de búsqueda</h1>
            <section id="nuevoSection">
                <article>
                    <h2 id="definicion">Definición</h2><br>
                    <p>Es un tipo especial de árbol binario, donde los nodos dentro del subarbol izquierdo son menores o iguales a el nodo raíz, y los nodos dentro del subárbol derecho son iguales o mayores a la raíz (Ver figura 2). Esta estructura de datos posee una gran relevancia en los sistemas, pues permite buscar, agregar y eliminar elementos, realizando la menor cantidad de cálculos computacionales, es decir, de manera muy eficiente [2].</p><br>
                    <img id="imgEstructura" src="Estilos, scripts e imagenes/Arboles binarios de busqueda.png" alt="Árbol binario de busqueda">
                    <p id="descripcionImagen">Figura 11: Representación de un árbol binario de búsqueda</p>
                </article>
            </section>

            <aside id="indice">
                <h2 id="tituloIndice">Índice</h2>
                <ul id="ulindice">
                    <li><a class="liindice" href="#definicion">1. Definición de un árbol binario de búsqueda</a></li>
                    <li><a class="liindice" href="#principalesMetodos">2. Principales métodos</a></li>
                    <li> <a class="liindice" href="#java">3. Implementación en Java</a>
                        <ul>
                            <li><a class="liindice" href="#nodoJava">3.1 Nodo del árbol</a></li>
                            <li><a class="liindice" href="#implementacionJava">3.2 Desarrollo del árbol binario de búsqueda</a></li>
                        </ul>
                    </li>
                    <li><a class="liindice" href="#c++">4. Implementación en C++</a>
                        <ul>
                            <li><a class="liindice" href="#nodoc++">4.1 Nodo del árbol</a></li>
                            <li><a class="liindice" href="#implementacionC++">4.2 Desarrollo del árbol binario de búsqueda</a></li>
                        </ul>
                    </li>
                    <li><a class="liindice" href="#python"> 5. Implementación en Python</a>
                        <ul>
                            <li><a class="liindice" href="#nodopython">5.1 Nodo del árbol</a></li>
                            <li><a class="liindice" href="#implementacionPython">5.2 Desarrollo del árbol binario de búsqueda</a></li>
                        </ul>
                    </li>  
                    <li><a class="liindice" href="#aplicacion">6. Ejercicio de aplicación de la estructura</a></li>      
                </ul>
            </aside>

            <section class="implementacion">
                <article>
                    <h2 id="principalesMetodos">Principales métodos</h2><br>
                    <ul>
                        <li><p><b>IsEmpty ()</b> -> Método Boolean el cual se encarga de verificar si el árbol contiene al menos un elemento (En este caso que exista su raíz); Retornara un true si es así y un false si la estructura está vacía.</p></li><br>
                        <li><p><b>insert (Object object,int id)</b> -> Método Boolean el cual se encarga de insertar un nodo dentro del árbol acorde a el id que se es solicitado como parámetro; Retornara un true si el proceso es completado, o un false si la raíz no existe o capte cualquier otro error.</p></li><br>
                        <li><p><b>preOrder (Node root)</b> -> Método String el cual se encarga de retornar un conjunto de caracteres los cuales representan el contenido completo del árbol según cierto orden; En este caso se expresa de izquierda a derecha el contenido de la raíz, el sub árbol izquierdo y finalmente el sub árbol derecho.</p></li><br>
                        <li><p><b>inOrder (Node root)</b> -> Método String el cual se encarga de retornar un conjunto de caracteres los cuales representan el contenido completo del árbol según cierto orden; En este caso se expresa de izquierda a derecha el contenido del sub árbol izquierdo, la raíz y finalmente el sub árbol derecho.</p></li><br>
                        <li><p><b>posOrder (Node root)</b> -> Método String el cual se encarga de retornar un conjunto de caracteres los cuales representan el contenido completo del árbol según cierto orden; En este caso se expresa de izquierda a derecha el contenido del sub árbol izquierdo, el sub árbol derecho y finalmente la raíz.</p></li><br>
                        <li><p><b></b>search (Object u)</b> -> Método Boolean el cual se encarga de recorrer el árbol y verificar que el elemento ingreso en el parámetro este en la estructura; Retornara un true si lo encuentra o un false si no está.</p></li><br>
                        <li><p><b>remove (int o, Object object)</b> -> Método void el cual se encarga de eliminar el nodo con el id ingresado en el parámetro (Para el funcionamiento de este método se debe saber que: Si es una hoja, se elimina; Si es una rama con un solo hijo, se reemplaza la rama por el hijo; Si es una rama con dos hijos, se debe que tomar dos caminos, irse por el sub árbol izquierdo y tomar el nodo que esta más por la derecha o irse por el sub árbol derecho y tomar el nodo que este más por la izquierda).</p></li><br>
                    </ul>
                </article>
                <article>
                    <h2 id="java">Implementación de la estructura en Java</h2>
                    <br>
                    <h3 id="nodoJava">Nodo de un árbol binario de búsqueda</h3>
                    <br>
                    <pre>
                        <code id="showCode" class="language-java">
public class Node {

    //ATRIBUTOS

    private Object object;
    public Node right;
    public Node left;
    private int id;

    //MÉTODOS Y CONSTRUCTORES

    //Constructores
    public Node(Object o, int id){
        this.object = o;
        this.right = null;
        this.left = null;
        this.id = id;
    }

    public Node(Node left,Object object, Node right, int id) {
        this.object = object;
        this.left = left;
        this.right = right;
        this.id = id;
    }

    public int GetID(){
        return id;
    }

    //Getter deL atributo object
    public Object GetObject() {
        return object;
    }

    //Método del cálculo del grado de un nodo
    public int Grado(){
        if (right==null & left==null){
            return 0;
        }else if ((right == null & left!=null) | (right != null & left==null)){
            return 1;
        }else{
            return 2;
        }
    }

    //Método toString
    @Override
    public String toString() {
        return "Node{ left=" + left + ", right=" + right + ", object=" + object + ", id=" + id + '}';
    }
}                            
                        </code>
                    </pre>
                    <br>
                    <h3 id="implementacionJava">Árbol binario de búsqueda</h3>
                    <br>
                    <pre>
                        <code id="showCode" class="language-java">
public class BinSearchTree {

    //ATRIBUTOS

    private String preorder = "", inorder = "", posorder = "";
    public Node root;

    //MÉTODOS Y CONSTRUCTORES

    //Constructores

    public BinSearchTree(){
        this.root = null;
    }

    public BinSearchTree(Object o, int id){
        this.root = new Node(null, o, null, id);
    }

    //Método IsEmpty

    public boolean IsEmpty(){
        if (root == null){
            return true;
        }else{
            return false;
        }
    }

    //Método Insert
    public boolean Insert(Object o, int id){
        if (!IsEmpty()){
            Node inode = root;
            while (inode!=null){
                if (inode.GetID()<=id){
                    if(inode.right != null){
                        inode = inode.right;
                    }else{
                        inode.right = new Node(null,o,null,id);
                        break;
                    }
                }else{
                    if(inode.left != null){
                        inode = inode.left;
                    }else{
                        inode.left = new Node(null,o,null,id);
                        break;
                    }
                }
            }
        }else{
            root = new Node(null,o,null,id);
        }
        return true;
    }

    //Métodos necesarios para realizar el search

    private Node search(Node root, int value) {
        if (root != null) {
            if (root.GetID() == value) {
                return root;
            } else if (root.GetID() < value) {
                return search(root.right, value);
            } else {
                return search(root.left, value);
            }
        }

        return null;
    }

    public Node search(int value) {
        return search(this.root, value);
    }

    //Método remove
    public boolean Remove(int id){
        if (!IsEmpty()){
            Node inode = root;
            Node preInode = root;
            while(inode.GetID() != id){
                preInode = inode;
                if (inode.GetID()>id){
                    inode = inode.left;
                }else{
                    inode = inode.right;
                }
                if (inode == null){
                    return false;
                }
            }
            if (inode.right == null & inode.left== null){
                if (inode == root){
                    root = null;
                }else if(preInode.left == inode){
                    preInode.left = null;
                }else{
                    preInode.right = null;
                }
            }else if(inode.right == null){
                if (inode == root){
                    root = root.left;
                }else if (preInode.left == inode){
                    preInode.left = inode.left;
                }
                else{
                    preInode.right = inode.left;
                }
            }else if(inode.left == null){
                if (inode == root){
                    root = root.right;
                }else if (preInode.left == inode){
                    preInode.left = inode.right;
                }
                else{
                    preInode.right = inode.right;
                }
            }else{
                Node rePre = inode, re = inode, aux = inode.right;
                while (aux != null){
                    rePre = re;
                    re = aux;
                    aux = aux.left;
                }
                if (re != inode.right){
                    rePre.left = re.right;
                    re.right = inode.right;
                }

                if (inode==root){
                    root = re;
                }else if(preInode.left == inode){
                    preInode.left = re;
                }else{
                    preInode.right = re;
                }
                re.left = inode.left;
            }
        }else{
            return false;
        }
        return true;
    }

    //Métodos necesarios para realizar el preorder
    private void PreOrder(Node n){
        if (!IsEmpty()){
            preorder += (String) n.GetObject();
            if (n.left!=null){
                PreOrder(n.left);
            }
            if (n.right!=null){
                PreOrder(n.right);
            }
        }
    }

    public String GetPreOrder(){
        PreOrder(root);
        return preorder;
    }

    //Métodos necesarios para realizar el inorder
    private void InOrder(Node n){
        if (!IsEmpty()){
            if (n.left!=null){
                InOrder(n.left);
            }
            inorder += (String) n.GetObject();
            if (n.right!=null){
                InOrder(n.right);
            }
        }
    }

    public String GetInOrder(){
        InOrder(root);
        return inorder;
    }

    //Métodos necesarios para realizar el posorder
    private void PosOrder(Node n){
        if (!IsEmpty()){
            if (n.left!=null){
                PosOrder(n.left);
            }
            if (n.right!=null){
                PosOrder(n.right);
            }
            posorder += (String) n.GetObject();
        }
    }

    public String GetPosOrder(){
        PosOrder(root);
        return posorder;
    }
}                            
                        </code>
                    </pre>
                </article>
            </section>

            <section class="implementacion">
                <article>
                    <h2 id="c++">Implementación de la estructura en C++</h2>
                    <br>
                    <h3 id="nodoc++">Nodo de un árbol binario de búsqueda</h3>
                    <br>
                    <pre>
                        <code id="showCode" class="language-cpp">
#include "BinSearchTree.h"
#pragma once
#include "Node.h"
#include < string >
#include < any >

using namespace std

class Node{
    
    //ATRIBUTOS
    private:
        std::any object;
    public:
        Node *right;
        Node *left;
    private:
        int id = 0;
    
    //MÉTODOS Y CONSTRUCTORES
    //Constructores
    Node::Node(std::any o, int id)
    {
        this->object = o;
        this->right = nullptr;
        this->left = nullptr;
        this->id = id;
    }

    Node::Node(Node *left, std::any object, Node *right, int id)
    {
        this->object = object;
        this->left = left;
        this->right = right;
        this->id = id;
    }

    int Node::GetID()
    {
        return id;
    }

    std::any Node::GetObject()
    {
        return object;
    }

    int Node::Grado()
    {
        if (right == nullptr & left == nullptr)
        {
            return 0;
        }
        else if ((right == nullptr & left != nullptr) | (right != nullptr & left == nullptr))
        {
            return 1;
        }
        else
        {
            return 2;
        }
    }
    
    //Método toString
    std::wstring Node::toString()
    {
        return L"Node{ left=" + left + L", right=" + right + L", object=" + object + L", id=" + std::to_wstring(id) + StringHelper::toString(L'}');
    }
};                           
                        </code>
                    </pre>

                    <br>
                    <h3 id="implementacionC++">Árbol binario de búsqueda</h3>
                    <br>
                    <pre>
                        <code id="showCode" class="language-cpp">
#include "BinSearchTree.h"
#pragma once
#include "Node.h"
#include < string >
#include < any >

using namespace std

class BinSearchTree{
    
        //ATRIBUTOS
    private:
        std::wstring preorder = L"", inorder = L"", posorder = L"";
    public:
        Node *root;
    
    //MÉTODOS Y CONSTRUCTORES

    BinSearchTree::BinSearchTree()
    {
        this->root = nullptr;
    }

    BinSearchTree::BinSearchTree(std::any o, int id)
    {
        this->root = new Node(nullptr, o, nullptr, id);
    }
    //Método IsEmpty
    bool BinSearchTree::IsEmpty()
    {
        if (root == nullptr)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    //Método Insert
    bool BinSearchTree::Insert(std::any o, int id)
    {
        if (!IsEmpty())
        {
            Node *inode = root;
            while (inode != nullptr)
            {
                if (inode->GetID() <= id)
                {
                    if (inode->right != nullptr)
                    {
                        inode = inode->right;
                    }
                    else
                    {
                        inode->right = new Node(nullptr,o,nullptr,id);
                        break;
                    }
                }
                else
                {
                    if (inode->left != nullptr)
                    {
                        inode = inode->left;
                    }
                    else
                    {
                        inode->left = new Node(nullptr,o,nullptr,id);
                        break;
                    }
                }
            }
        }
        else
        {
            root = new Node(nullptr,o,nullptr,id);
        }
        return true;
    }

    //Métodos necesarios para realizar el search en el árbol AVL
    
	Node search(Node root, int value)
	{
		if (root != nullptr)
		{
			if (root::GetID() == value)
			{
				return root;
			}
			else if (root::GetID() < value)
			{
				return search(root::right, value);
			}
			else
			{
				return search(root::left, value);
			}
		}
		return nullptr;
	}	

	Node search(int value)
	{
		return search(this->root, value);
	}

    //Método remove
    bool BinSearchTree::SearchObject(std::any o)
    {
        Search(root,o);
        if (search == true)
        {
            search = false; //Se vuelve a dejar la variable booleana en false para en un futuro poder volverla a usar
            return true;
        }
        else
        {
            return false;
        }
    }
    
    bool BinSearchTree::Remove(int id)
    {
        if (!IsEmpty())
        {
            Node *inode = root;
            Node *preInode = root;
            while (inode->GetID() != id)
            {
                preInode = inode;
                if (inode->GetID() > id)
                {
                    inode = inode->left;
                }
                else
                {
                    inode = inode->right;
                }
                if (inode == nullptr)
                {
                    return false;
                }
            }
            if (inode->right == nullptr & inode->left == nullptr)
            {
                if (inode == root)
                {
                    root = nullptr;
                }
                else if (preInode->left == inode)
                {
                    preInode->left = nullptr;
                }
                else
                {
                    preInode->right = nullptr;
                }
            }
            else if (inode->right == nullptr)
            {
                if (inode == root)
                {
                    root = root::left;
                }
                else if (preInode->left == inode)
                {
                    preInode->left = inode->left;
                }
                else
                {
                    preInode->right = inode->left;
                }
            }
            else if (inode->left == nullptr)
            {
                if (inode == root)
                {
                    root = root::right;
                }
                else if (preInode->left == inode)
                {
                    preInode->left = inode->right;
                }
                else
                {
                    preInode->right = inode->right;
                }
            }
            else
            {
                Node *rePre = inode, *re = inode, *aux = inode->right;
                while (aux != nullptr)
                {
                    rePre = re;
                    re = aux;
                    aux = aux->left;
                }
                if (re != inode->right)
                {
                    rePre->left = re->right;
                    re->right = inode->right;
                }

                if (inode == root)
                {
                    root = re;
                }
                else if (preInode->left == inode)
                {
                    preInode->left = re;
                }
                else
                {
                    preInode->right = re;
                }
                re->left = inode->left;
            }
        }
        else
        {
            return false;
        }
        return true;
    }
    //Métodos necesarios para realizar el preorder
    void BinSearchTree::PreOrder(Node *n)
    {
        if (!IsEmpty())
        {
            preorder += static_cast< ::wstring >(n->GetObject());
            if (n->left != nullptr)
            {
                PreOrder(n->left);
            }
            if (n->right != nullptr)
            {
                PreOrder(n->right);
            }
        }
    }

    std::wstring BinSearchTree::GetPreOrder()
    {
        PreOrder(root);
        return preorder;
    }

    //Métodos necesarios para realizar el inorder
    void BinSearchTree::InOrder(Node *n)
    {
        if (!IsEmpty())
        {
            if (n->left != nullptr)
            {
                InOrder(n->left);
            }
            inorder += static_cast< std::wstring >(n->GetObject());
            if (n->right != nullptr)
            {
                InOrder(n->right);
            }
        }
    }

    std::wstring BinSearchTree::GetInOrder()
    {
        InOrder(root);
        return inorder;
    }
    //Métodos necesarios para realizar el posorder
    void BinSearchTree::PosOrder(Node *n)
    {
        if (!IsEmpty())
        {
            if (n->left != nullptr)
            {
                PosOrder(n->left);
            }
            if (n->right != nullptr)
            {
                PosOrder(n->right);
            }
            posorder += static_cast< std::wstring >(n->GetObject());
        }
    }

    std::wstring BinSearchTree::GetPosOrder()
    {
        PosOrder(root);
        return posorder;
    }
};                                                                                                            
                        </code>
                </article>
            </section>

            <section class="implementacion">
                <article>
                    <h2 id="python">Implementación de la estructura en Python</h2>
                    <br>
                    <h3 id="nodopython">Nodo de un árbol binario de búsqueda</h3>
                    <br>
                    <pre>
                        <code id="showCode" class="language-python">
class Node():

__object = None #Variable para almacenar el objeto del nodo
__key = 0
right = None  #Indicador de nodo derecho siguiente
left = None  #Indicador de nodo izquierdo siguiente

"""
Inicializador, recibe un objeto, y puede recibir los enlaces de este. 
"""
def __init__(self, ob,key, left = None , right = None):
    self.__object = ob
    self.__key = key
    self.right = right
    self.left = left


"""
Retorna el objeto del nodo, no recibe parametros. 
"""
def GetObject(self):
    return self.__object

"""
Retorna la llave o id del nodo, no recibe parametros. 
"""
def GetKey(self):
    return self.__key

"""
Evaluar si un nodo u objeto, es equivalente al nodo, esto se hace comparando
unicamente las __object con el parametro dado
"""
def isEquals(self, objectt):
    if(type(objectt)==Node):
        if(self.__object == objectt.getObject()):#Si el elemento entregado como parametro "objectt" no es un nodo, se genera error y se va al try donde si se puede evaluar si esta en la Lista
            return True
    else:
        if(self.__object == objectt):
            return True
    return False


"""
Retorna el grado del nodo, no recibe parametros. 
"""
def Grado(self):
    if(self.right == None and self.left==None):
        return 0
    elif((self.right == None and self.left!=None) or (self.right != None and self.left==None)):
        return 1
    else:
        return 2

"""
Metodo para imprimir un nodo, no recibe parametros.  
"""
def __str__(self):
    return "Node [left: {0}, right: {1}, object {2}]".format(self.left,self.right,self.GetObject())                        
                        </code>
                    </pre>

                    <br>
                    <h3 id="implementacionPython">Árbol binario de búsqueda</h3>
                    <br>
                    <pre>
                        <code id="showCode" class="language-python">
from Node import Node


class BSTree(Node):

    __search = False
    root = None#Node()


    """
    Inicializador de la clase.
    """
    def __init__(self, ob = None, key = None):
        if(ob != None and key == None):
            raise Exception("No key given for the node")
            self.root = Node(ob,key)
        else:
            self.root = None


    """
    Como cada nodo de un arbol binario, puede ser a la misma vez un arbol binario
    con este metodo se crean sub arboles binarios, recibe un objeto, y los nodos
    derechos e izquierdos, y retorna un nodo con estos atributos.
    """
    def SubBSTree(self,left, ob, right):
        temp = Node(ob, left, right)
        # CalcularGradoArbol(temp)
        return temp;
    
    """
    Retorna True si la lista esta vacia
    """
    def IsEmpty(self):
        return self.root == None


    """
    Inserta un elemento en la lista de acuerdo con la llave entregada como parametro.
    """
    def Insert(self, ob, key):
        if(not self.IsEmpty()):
            inode = self.root

            while(inode!=None):
                if(inode.GetKey()<= key):
                    if(inode.right != None):
                        inode = inode.right
                    else:
                        inode.right = Node(ob,key)
                        return True
                else:
                    if (inode.left!=None):
                        inode = inode.left
                    else:
                        inode.left = Node(ob,key)
                        return True
        else:
            root = Node(ob, key)
        return False

    """
    Busca un elemento en el arbol de forma recursiva, de acuerdo con la llave dada,
    este es un metodo privado.
    """
    def _Search(self,root, key):
        if(root != None):
            if(root.GetKey() == key):
                return root
            elif(root.GetKey() < key):
                return self._Search(root.right,key)
            else:
                return self._Search(root.left,key)
        return None

    """
    Busca un elemento en el arbol de acuerdo a la llave dada como parametro,
    utilizando _Search.
    """
    def Search(self, key):
        return self._Search(self.root,key)

    """
    Remueve un nodo del arbol, de acuerdo al id o llave dada como parametro
    retorna True si fue eliminado.
    """
    def Remove(self,key):
        if(not self.IsEmpty()):
            """
            Recorre el arbol y si la llave existe, obtiene el nodo al que 
            pertenece.
            """
            inode = self.root
            preinode = self.root
            while(inode.GetKey()!= key):
                preinode = inode
                if(inode.GetKey()>key):
                    inode = inode.left
                else:
                    inode = inode.right
                if(inode==None):
                    return False
            """
            Elimina el nodo.
            """
            if(inode.right==None and inode.left==None): #No tiene hijos
                if(inode == self.root):
                    self.root = None
                elif(preinode.left == inode):
                    preinode.left = None
                else:
                    preinode.right = None
            elif(inode.right == None): #Es una rama con un hijo
                if(inode ==self.root):
                    self.root = self.root.left
                elif(preinode.left == inode):
                    preinode.left = inode.left
                else:
                    preinode.right = inode.left
            elif(inode.left == None): #Es una rama con un hijo
                if(inode ==self.root):
                    self.root = self.root.right
                elif(preinode.left == inode):
                    preinode.left = inode.right
                else:
                    preinode.right = inode.right
            else: #Es una rama con 2 hijos
                rePre = inode
                re = inode
                aux = inode.right
                """
                Hallar 
                """
                while(aux != None):
                    rePre = re
                    re = aux
                    aux = aux.left

                if(re != inode.right):
                    rePre.left = re.right
                    re.right = inode.right
                
                if(inode == self.root):
                    self.root = re
                elif(preinode.left == inode):
                    preinode.left = re
                else:
                    preinode.right = re
                re.left = inode.left
                return True
        else:
            return False


    """
    Realiza el recorrido preOrder de forma recursiva, y lo almacena en una variable de tipo string, metodo privado
    """
    def _preOrder(self,root):
        if(root != None):
            print((str(root.GetObject()) + " " if (root != None) else ""), end ="")
            self._preOrder(root.left)
            self._preOrder(root.right)
    
    """
    Imprime el resultado del recorrido _preOrder
    """
    def preOrder(self):
        if(not self.IsEmpty()):
            self._preOrder(self.root)
        else:
            print("El arbol esta vacio.")

    """
    Realiza el recorrido inOrder de forma recursiva, y lo almacena en una variable de tipo string
    """
    def _inOrder(self,root):
        if(root != None):
            self._inOrder(root.left)
            print((str(root.GetObject()) + " " if (root != None) else ""), end ="")
            self._inOrder(root.right)

    """
    Imprime el resultado del recorrido _inOrder
    """
    def inOrder(self):
        if(not self.IsEmpty()):
            self._inOrder(self.root)
        else:
            print("El arbol esta vacio.")
    
    """
    Realiza el recorrido posOrder de forma recursiva, y lo almacena en una variable de tipo string
    """
    def _posOrder(self,root):
        if(root != None):
            self._posOrder(root.left)
            self._posOrder(root.right)
            print((str(root.GetObject()) + " " if (root != None) else ""), end ="")

    """
    Imprime el resultado del recorrido _posOrder
    """
    def posOrder(self):
        if(not self.IsEmpty()):
            self._posOrder(self.root)
        else:
            print("El arbol esta vacio.")                            
                        </code>
                    </pre>
                </article>
            </section>

            <section class="implementacion">
                <article>
                    <h2 id="aplicacion">Ejercicio de aplicación del árbol binario de búsqueda</h2>
                    <br>
                    <p>Escribir un programa de una longitud indeterminada que lea un texto y produzca una impresión de todas las palabras diferentes con su debida frecuencia de aparición; Hacer uso de los arboles para que cada nodo tenga una palabra con su respectiva frecuencia como su identificador.</p><br>            
                    <pre>
                        <code id="showCode" class="language-java">
import java.util.*;

public class Main {

    public static void main(String[] args) {

        BinSearchTree arbol = new BinSearchTree(); // Árbol Binario de Búsqueda
        ArrayList base = new ArrayList(); // ArrayList

        Scanner p = new Scanner(System.in);
        System.out.println("Digite el texto");
        String data = p.nextLine();
        String xd = "";
        for(int i = 0 ; i < data.length() ; i++){
            char u = data.charAt(i);
            if(u == ' ' || u == '.' || u== ';' || u ==',' || u == '!' || u == '¡'){ //Se separa las palabras por medio de estos caracteres
                base.add(xd);
                xd = "";
            }else{
                xd+=u;
            }
        }
        if(xd.length() != 0){ // Si al final del texto , este no posee un finalizador , el programa automaticamente lo agrega
            base.add(xd);
            xd="";
        }
        Set< Object > miSet = new HashSet< Object >(base);// Set para contar los elementos
        for(Object s: miSet){
            System.out.println(s + " " +Collections.frequency(base,s)); // Se identifican las palabras y su frecuencia dentro del texto
            int cont = Collections.frequency(base,s);
            arbol.Insert(s,cont); // Se agrega cada palabra al arbol basada en su frecuencia mediante el .insert
        }
        System.out.println("Su impresión en pre-order es" + " " + arbol.GetPreOrder());
    }
}
                        </code>
                    </pre>
                <p id="descripcionImagen">EJERCICIO TOMADO DE [3]</p>
                </article>
                <a href="#principio"><img id="botonArriba" src="Estilos, scripts e imagenes/Boton arriba.png"></a>
            </section>
            
            <footer id="pie">
                Universidad Pontificia Bolivariana - Seccional Bucaramanga
            </footer>
        </div>
        <script src="Estilos, scripts e imagenes/prism.js"></script>
    </body>
</html>